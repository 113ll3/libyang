From: Michal Vasko <mvasko@cesnet.cz>
Date: Mon, 29 Jun 2020 10:47:11 +0200
Subject: data tree BUGFIX hash canonical values for leaves

Also, always compare on canonical values when
resolving partial path in lyd_new_path().

Fixes #1119
---
 src/resolve.c   | 136 ++++++++++----------------------------------------------
 src/tree_data.c |  55 +++++++----------------
 2 files changed, 40 insertions(+), 151 deletions(-)

diff --git a/src/resolve.c b/src/resolve.c
index 10e4af1..622b1cf 100644
--- a/src/resolve.c
+++ b/src/resolve.c
@@ -35,6 +35,9 @@
 /* internal parsed predicate structure */
 struct parsed_pred {
     const struct lys_node *schema;
+    const char *pred_str;
+    int pred_str_len;
+
     int len;
     struct {
         const char *mod_name;
@@ -1147,124 +1150,27 @@ parse_schema_json_predicate(const char *id, const char **mod_name, int *mod_name
     return parsed;
 }
 
-#ifdef LY_ENABLED_CACHE
-
-static int
-resolve_hash_table_find_equal(void *val1_p, void *val2_p, int mod, void *UNUSED(cb_data))
-{
-    struct lyd_node *val2, *elem2;
-    struct parsed_pred pp;
-    const char *str;
-    int i;
-
-    assert(!mod);
-    (void)mod;
-
-    pp = *((struct parsed_pred *)val1_p);
-    val2 = *((struct lyd_node **)val2_p);
-
-    if (val2->schema != pp.schema) {
-        return 0;
-    }
-
-    switch (val2->schema->nodetype) {
-    case LYS_CONTAINER:
-    case LYS_LEAF:
-    case LYS_ANYXML:
-    case LYS_ANYDATA:
-        return 1;
-    case LYS_LEAFLIST:
-        str = ((struct lyd_node_leaf_list *)val2)->value_str;
-        if (!strncmp(str, pp.pred[0].value, pp.pred[0].val_len) && !str[pp.pred[0].val_len]) {
-            return 1;
-        }
-        return 0;
-    case LYS_LIST:
-        assert(((struct lys_node_list *)val2->schema)->keys_size);
-        assert(((struct lys_node_list *)val2->schema)->keys_size == pp.len);
-
-        /* lists with keys, their equivalence is based on their keys */
-        elem2 = val2->child;
-        /* the exact data order is guaranteed */
-        for (i = 0; elem2 && (i < pp.len); ++i) {
-            /* module check */
-            if (pp.pred[i].mod_name) {
-                if (strncmp(lyd_node_module(elem2)->name, pp.pred[i].mod_name, pp.pred[i].mod_name_len)
-                        || lyd_node_module(elem2)->name[pp.pred[i].mod_name_len]) {
-                    break;
-                }
-            } else {
-                if (lyd_node_module(elem2) != lys_node_module(pp.schema)) {
-                    break;
-                }
-            }
-
-            /* name check */
-            if (strncmp(elem2->schema->name, pp.pred[i].name, pp.pred[i].nam_len) || elem2->schema->name[pp.pred[i].nam_len]) {
-                break;
-            }
-
-            /* value check */
-            str = ((struct lyd_node_leaf_list *)elem2)->value_str;
-            if (strncmp(str, pp.pred[i].value, pp.pred[i].val_len) || str[pp.pred[i].val_len]) {
-                break;
-            }
-
-            /* next key */
-            elem2 = elem2->next;
-        }
-        if (i == pp.len) {
-            return 1;
-        }
-        return 0;
-    default:
-        break;
-    }
-
-    LOGINT(val2->schema->module->ctx);
-    return 0;
-}
-
 static struct lyd_node *
-resolve_json_data_node_hash(struct lyd_node *parent, struct parsed_pred pp)
+resolve_json_data_node_hash(struct lyd_node *siblings, struct parsed_pred pp)
 {
-    values_equal_cb prev_cb;
-    struct lyd_node **ret = NULL;
-    uint32_t hash;
-    int i;
+    struct lyd_node *ret = NULL;
+    char *key_or_value = NULL;
 
-    assert(parent && parent->hash);
-
-    /* set our value equivalence callback that does not require data nodes */
-    prev_cb = lyht_set_cb(parent->ht, resolve_hash_table_find_equal);
-
-    /* get the hash of the searched node */
-    hash = dict_hash_multi(0, lys_node_module(pp.schema)->name, strlen(lys_node_module(pp.schema)->name));
-    hash = dict_hash_multi(hash, pp.schema->name, strlen(pp.schema->name));
     if (pp.schema->nodetype == LYS_LEAFLIST) {
         assert((pp.len == 1) && (pp.pred[0].name[0] == '.') && (pp.pred[0].nam_len == 1));
-        /* leaf-list value in predicate */
-        hash = dict_hash_multi(hash, pp.pred[0].value, pp.pred[0].val_len);
+
+        key_or_value = strndup(pp.pred[0].value, pp.pred[0].val_len);
     } else if (pp.schema->nodetype == LYS_LIST) {
-        /* list keys in predicates */
-        for (i = 0; i < pp.len; ++i) {
-            hash = dict_hash_multi(hash, pp.pred[i].value, pp.pred[i].val_len);
-        }
+        key_or_value = strndup(pp.pred_str, pp.pred_str_len);
     }
-    hash = dict_hash_multi(hash, NULL, 0);
 
     /* try to find the node */
-    i = lyht_find(parent->ht, &pp, hash, (void **)&ret);
-    assert(i || *ret);
-
-    /* restore the original callback */
-    lyht_set_cb(parent->ht, prev_cb);
+    lyd_find_sibling_val(siblings, pp.schema, key_or_value, &ret);
+    free(key_or_value);
 
-    return (i ? NULL : *ret);
+    return ret;
 }
 
-#endif
-
 /**
  * @brief Resolve (find) a feature definition. Logs directly.
  *
@@ -2761,14 +2667,11 @@ resolve_partial_json_data_nodeid(const char *nodeid, const char *llist_value, st
             goto error;
         }
 
-#ifdef LY_ENABLED_CACHE
-        /* we will not be matching keyless lists or state leaf-lists this way */
-        if (start->parent && start->parent->ht && ((pp.schema->nodetype != LYS_LIST) || ((struct lys_node_list *)pp.schema)->keys_size)
+        /* we will not be matching list position, keyless lists, or state leaf-lists this way */
+        if (((pp.schema->nodetype != LYS_LIST) || (((struct lys_node_list *)pp.schema)->keys_size && !isdigit(pp.pred[0].name[0])))
                 && ((pp.schema->nodetype != LYS_LEAFLIST) || (pp.schema->flags & LYS_CONFIG_W))) {
-            sibling = resolve_json_data_node_hash(start->parent, pp);
-        } else
-#endif
-        {
+            sibling = resolve_json_data_node_hash(start, pp);
+        } else {
             list_instance_position = 0;
             LY_TREE_FOR(start, sibling) {
                 /* RPC/action data check, return simply invalid argument, because the data tree is invalid */
@@ -2881,9 +2784,15 @@ parse_predicates:
         /* parse all the predicates */
         free(pp.pred);
         pp.schema = NULL;
+        pp.pred_str = NULL;
+        pp.pred_str_len = 0;
         pp.len = 0;
         pp.pred = NULL;
         while (has_predicate) {
+            if (!pp.pred_str) {
+                pp.pred_str = id;
+            }
+
             ++pp.len;
             pp.pred = ly_realloc(pp.pred, pp.len * sizeof *pp.pred);
             LY_CHECK_ERR_GOTO(!pp.pred, LOGMEM(ctx), error);
@@ -2896,6 +2805,7 @@ parse_predicates:
 
             id += r;
             last_parsed += r;
+            pp.pred_str_len += r;
         }
     }
 
diff --git a/src/tree_data.c b/src/tree_data.c
index e07e90e..fa2662a 100644
--- a/src/tree_data.c
+++ b/src/tree_data.c
@@ -1205,7 +1205,7 @@ lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *na
 }
 
 static struct lyd_node *
-lyd_create_leaf(const struct lys_node *schema, const char *val_str, int dflt)
+lyd_create_leaf(const struct lys_node *schema, const char *val_str, int dflt, int edit_leaf)
 {
     struct lyd_node_leaf_list *ret;
 
@@ -1222,6 +1222,14 @@ lyd_create_leaf(const struct lys_node *schema, const char *val_str, int dflt)
     ret->value_str = lydict_insert(schema->module->ctx, val_str ? val_str : "", 0);
     ret->dflt = dflt;
 
+    if (edit_leaf && !ret->value_str[0]) {
+        /* empty edit leaf, it is fine */
+        ((struct lyd_node_leaf_list *)ret)->value_type = LY_TYPE_UNKNOWN;
+    } else if (!lyp_parse_value(&((struct lys_node_leaf *)schema)->type, &ret->value_str, NULL, ret, NULL, NULL, 1, dflt)) {
+        lyd_free((struct lyd_node *)ret);
+        return NULL;
+    }
+
 #ifdef LY_ENABLED_CACHE
     lyd_hash((struct lyd_node *)ret);
 #endif
@@ -1234,7 +1242,7 @@ _lyd_new_leaf(struct lyd_node *parent, const struct lys_node *schema, const char
 {
     struct lyd_node *ret;
 
-    ret = lyd_create_leaf(schema, val_str, dflt);
+    ret = lyd_create_leaf(schema, val_str, dflt, edit_leaf);
     if (!ret) {
         return NULL;
     }
@@ -1247,19 +1255,6 @@ _lyd_new_leaf(struct lyd_node *parent, const struct lys_node *schema, const char
         }
     }
 
-    if (edit_leaf && !((struct lyd_node_leaf_list *)ret)->value_str[0]) {
-        /* empty edit leaf, it is fine */
-        ((struct lyd_node_leaf_list *)ret)->value_type = LY_TYPE_UNKNOWN;
-        return ret;
-    }
-
-    /* resolve the type correctly (after it was connected to parent cause of log) */
-    if (!lyp_parse_value(&((struct lys_node_leaf *)ret->schema)->type, &((struct lyd_node_leaf_list *)ret)->value_str,
-                         NULL, (struct lyd_node_leaf_list *)ret, NULL, NULL, 1, dflt)) {
-        lyd_free(ret);
-        return NULL;
-    }
-
     if ((ret->schema->nodetype == LYS_LEAF) && (ret->schema->flags & LYS_UNIQUE)) {
         for (; parent && (parent->schema->nodetype != LYS_LIST); parent = parent->parent);
         if (parent) {
@@ -1631,19 +1626,13 @@ lyd_make_canonical(const struct lys_node *schema, const char *val_str, int val_s
         return NULL;
     }
 
-    node = lyd_create_leaf(schema, str, 0);
+    /* parse the value into a fake leaf */
+    node = lyd_create_leaf(schema, str, 0, 0);
     free(str);
     if (!node) {
         return NULL;
     }
 
-    /* parse the value into a fake leaf */
-    if (!lyp_parse_value(&((struct lys_node_leaf *)node->schema)->type, &((struct lyd_node_leaf_list *)node)->value_str,
-                         NULL, (struct lyd_node_leaf_list *)node, NULL, NULL, 1, 0)) {
-        lyd_free(node);
-        return NULL;
-    }
-
     str = strdup(((struct lyd_node_leaf_list *)node)->value_str);
     lyd_free(node);
     if (!str) {
@@ -2293,22 +2282,12 @@ lyd_new_dummy(struct lyd_node *root, struct lyd_node *parent, const struct lys_n
             }
         }
     }
-    while(index) {
+    while (index) {
         /* create the missing part of the path */
         switch (spath->set.s[index - 1]->nodetype) {
         case LYS_LEAF:
         case LYS_LEAFLIST:
-            if (value) {
-                iter = _lyd_new_leaf(parent, spath->set.s[index - 1], value, dflt, 0);
-            } else {
-                iter = lyd_create_leaf(spath->set.s[index - 1], value, dflt);
-                if (iter && parent) {
-                    if (lyd_insert(parent, iter)) {
-                        lyd_free(iter);
-                        goto error;
-                    }
-                }
-            }
+            iter = _lyd_new_leaf(parent, spath->set.s[index - 1], value, dflt, 1);
             break;
         case LYS_CONTAINER:
         case LYS_LIST:
@@ -6892,12 +6871,12 @@ lyd_find_sibling_val(const struct lyd_node *siblings, const struct lys_node *sch
         break;
     case LYS_LEAF:
         /* used attributes: schema, hash */
-        target = lyd_create_leaf(schema, NULL, 0);
+        target = lyd_create_leaf(schema, NULL, 0, 1);
         LY_CHECK_RETURN(!target, -1);
         break;
     case LYS_LEAFLIST:
         /* used attributes: schema, hash, value_str */
-        target = lyd_create_leaf(schema, key_or_value, 0);
+        target = lyd_create_leaf(schema, key_or_value, 0, 0);
         LY_CHECK_RETURN(!target, -1);
         break;
     case LYS_LIST:
@@ -6918,7 +6897,7 @@ lyd_find_sibling_val(const struct lyd_node *siblings, const struct lys_node *sch
             LY_CHECK_GOTO(!val, error);
 
             /* create and insert key */
-            node = lyd_create_leaf(key, val, 0);
+            node = lyd_create_leaf(key, val, 0, 0);
             if (!node || lyd_insert(target, node)) {
                 lyd_free(node);
                 goto error;
